---
title: Using BepInEx
description: Advanced BepInEx features and techniques for Resonite modding
---

This guide covers advanced BepInEx features for Resonite mod development.

## BepInEx Architecture

### Plugin Lifecycle

1. **Preloader** - Patches assemblies before game starts
2. **Chainloader** - Discovers and loads plugins
3. **Plugin Initialization** - Awake() called on plugins
4. **Runtime** - Plugins active during gameplay

## Plugin Attributes

### BepInPlugin
Required attribute for all plugins:
```csharp
[BepInPlugin(GUID, Name, Version)]
public class MyPlugin : BaseUnityPlugin
{
    const string GUID = "com.example.myplugin";
    const string Name = "My Plugin";
    const string Version = "1.0.0";
}
```

### BepInDependency
Specify plugin dependencies:
```csharp
[BepInDependency("com.other.plugin", BepInDependency.DependencyFlags.HardDependency)]
[BepInDependency("com.optional.plugin", BepInDependency.DependencyFlags.SoftDependency)]
public class MyPlugin : BaseUnityPlugin { }
```

### BepInIncompatibility
Mark incompatible plugins:
```csharp
[BepInIncompatibility("com.conflicting.plugin")]
public class MyPlugin : BaseUnityPlugin { }
```

### BepInProcess
Target specific processes:
```csharp
[BepInProcess("Resonite.exe")]
public class MyPlugin : BaseUnityPlugin { }
```

## Configuration System

### Basic Configuration
```csharp
public class MyPlugin : BaseUnityPlugin
{
    private ConfigEntry<bool> EnableFeature;
    private ConfigEntry<float> Multiplier;
    private ConfigEntry<KeyCode> Hotkey;
    
    private void Awake()
    {
        EnableFeature = Config.Bind(
            "General",           // Section
            "Enable Feature",    // Key
            true,               // Default value
            "Enables the main feature" // Description
        );
        
        Multiplier = Config.Bind(
            "Gameplay",
            "Speed Multiplier",
            1.0f,
            new ConfigDescription(
                "Speed multiplication factor",
                new AcceptableValueRange<float>(0.1f, 10f)
            )
        );
        
        Hotkey = Config.Bind(
            "Controls",
            "Toggle Key",
            KeyCode.F5
        );
    }
}
```

### Advanced Configuration
```csharp
// Custom config file
var customConfig = new ConfigFile(
    Path.Combine(Paths.ConfigPath, "custom.cfg"),
    true
);

// Config with custom drawer
Config.Bind(
    "Advanced",
    "Complex Setting",
    new Vector3(1, 2, 3),
    new ConfigDescription(
        "A complex vector setting",
        null,
        new ConfigurationManagerAttributes {
            IsAdvanced = true,
            Order = 100
        }
    )
);
```

### Runtime Configuration Changes
```csharp
// Listen for changes
EnableFeature.SettingChanged += (sender, args) =>
{
    Logger.LogInfo($"Feature toggled: {EnableFeature.Value}");
    ApplySettings();
};

// Save configuration
Config.Save();

// Reload configuration
Config.Reload();
```

## Logging System

### Log Levels
```csharp
Logger.LogFatal("Fatal error - mod cannot continue");
Logger.LogError("Error occurred but mod can continue");
Logger.LogWarning("Something unexpected but handled");
Logger.LogMessage("Important information");
Logger.LogInfo("General information");
Logger.LogDebug("Debug information");
```

### Custom Log Source
```csharp
var customLog = BepInEx.Logging.Logger.CreateLogSource("CustomSystem");
customLog.LogInfo("Custom log message");
```

### Log Filtering
Configure in `BepInEx.cfg`:
```ini
[Logging.Console]
LogLevels = Fatal, Error, Warning, Message, Info
# Exclude Debug

[Logging.Disk]
LogLevels = All
```

## Harmony Integration

### Manual Patching
```csharp
public class MyPlugin : BaseUnityPlugin
{
    private Harmony harmony;
    
    private void Awake()
    {
        harmony = new Harmony(Info.Metadata.GUID);
        
        // Patch specific method
        var original = typeof(World).GetMethod("Initialize");
        var prefix = typeof(MyPatch).GetMethod("Prefix");
        harmony.Patch(original, prefix: new HarmonyMethod(prefix));
        
        // Or patch all in assembly
        harmony.PatchAll();
    }
    
    private void OnDestroy()
    {
        harmony?.UnpatchSelf();
    }
}
```

### Conditional Patching
```csharp
[HarmonyPatch]
public class ConditionalPatch
{
    static bool Prepare()
    {
        // Return false to skip this patch
        return Config.EnablePatch.Value;
    }
    
    static MethodBase TargetMethod()
    {
        // Dynamically determine method to patch
        return typeof(World).GetMethod("Update");
    }
    
    static void Postfix()
    {
        // Patch logic
    }
}
```

### Priority and Execution Order
```csharp
[HarmonyPatch(typeof(World), "Initialize")]
[HarmonyPriority(Priority.First)]  // Run before other patches
public class EarlyPatch
{
    static void Prefix() { }
}

[HarmonyPatch(typeof(World), "Initialize")]
[HarmonyPriority(Priority.Last)]   // Run after other patches
[HarmonyAfter("com.other.mod")]    // Run after specific mod
public class LatePatch
{
    static void Prefix() { }
}
```

## Resource Management

### Embedded Resources
```csharp
public class MyPlugin : BaseUnityPlugin
{
    private void LoadResources()
    {
        // Load embedded resource
        var assembly = Assembly.GetExecutingAssembly();
        var resourceName = "MyPlugin.Resources.config.json";
        
        using (var stream = assembly.GetManifestResourceStream(resourceName))
        using (var reader = new StreamReader(stream))
        {
            string content = reader.ReadToEnd();
            ProcessConfig(content);
        }
    }
}
```

### Asset Bundles
```csharp
private void LoadAssetBundle()
{
    var bundlePath = Path.Combine(Paths.PluginPath, "MyPlugin", "assets");
    var bundle = AssetBundle.LoadFromFile(bundlePath);
    
    if (bundle != null)
    {
        var prefab = bundle.LoadAsset<GameObject>("MyPrefab");
        // Use prefab
        bundle.Unload(false);
    }
}
```

## Networking

### Custom Messages
```csharp
public class NetworkedMod : BaseUnityPlugin
{
    private void RegisterMessages()
    {
        // Register custom network message
        NetworkManager.RegisterMessageHandler<MyCustomMessage>(HandleMessage);
    }
    
    private void HandleMessage(MyCustomMessage msg)
    {
        Logger.LogInfo($"Received: {msg.Data}");
    }
    
    private void SendMessage(string data)
    {
        var msg = new MyCustomMessage { Data = data };
        NetworkManager.Send(msg);
    }
}
```

## Performance Monitoring

### Profiling
```csharp
using System.Diagnostics;

public class PerformanceMonitor
{
    private Stopwatch stopwatch = new Stopwatch();
    
    public void ProfileMethod()
    {
        stopwatch.Restart();
        
        // Code to profile
        ExpensiveOperation();
        
        stopwatch.Stop();
        Logger.LogInfo($"Operation took: {stopwatch.ElapsedMilliseconds}ms");
    }
}
```

### Memory Tracking
```csharp
private void LogMemoryUsage()
{
    var memory = GC.GetTotalMemory(false) / 1024 / 1024;
    Logger.LogInfo($"Memory usage: {memory}MB");
    
    // Force garbage collection if needed
    if (memory > 100)
    {
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
    }
}
```

## Inter-Plugin Communication

### Soft Dependencies
```csharp
public class MyPlugin : BaseUnityPlugin
{
    private bool otherPluginLoaded;
    
    private void Awake()
    {
        // Check if other plugin is loaded
        otherPluginLoaded = BepInEx.Bootstrap.Chainloader
            .PluginInfos.ContainsKey("com.other.plugin");
        
        if (otherPluginLoaded)
        {
            // Access other plugin
            var otherPlugin = BepInEx.Bootstrap.Chainloader
                .PluginInfos["com.other.plugin"].Instance;
            // Use reflection or interfaces
        }
    }
}
```

### Shared Interfaces
```csharp
// Shared library
public interface IModAPI
{
    void RegisterFeature(string name, Action callback);
}

// Plugin A - Provider
public class ProviderPlugin : BaseUnityPlugin, IModAPI
{
    public void RegisterFeature(string name, Action callback)
    {
        // Implementation
    }
}

// Plugin B - Consumer
public class ConsumerPlugin : BaseUnityPlugin
{
    private void Awake()
    {
        var provider = FindPlugin<IModAPI>("com.provider.plugin");
        provider?.RegisterFeature("MyFeature", OnFeatureActivated);
    }
}
```

## Security Considerations

### Input Validation
```csharp
public void ProcessUserInput(string input)
{
    // Sanitize input
    input = input.Trim();
    
    if (string.IsNullOrWhiteSpace(input))
        return;
    
    if (input.Length > 1000)
    {
        Logger.LogWarning("Input too long");
        return;
    }
    
    // Process safely
}
```

### Safe File Operations
```csharp
private void SaveData(string filename, string data)
{
    // Validate filename
    filename = Path.GetFileName(filename); // Remove path
    
    if (string.IsNullOrEmpty(filename))
        return;
    
    var safePath = Path.Combine(Paths.ConfigPath, filename);
    
    try
    {
        File.WriteAllText(safePath, data);
    }
    catch (Exception ex)
    {
        Logger.LogError($"Failed to save: {ex}");
    }
}
```

## Distribution

### Plugin Manifest
Create `manifest.json` for Thunderstore:
```json
{
    "name": "MyResoniteMod",
    "version_number": "1.0.0",
    "website_url": "https://github.com/user/mod",
    "description": "Description here",
    "dependencies": [
        "BepInExPack_Resonite-1.0.0",
        "OtherDependency-2.0.0"
    ]
}
```

### File Structure
```
MyMod.zip
├── manifest.json
├── icon.png (256x256)
├── README.md
└── plugins/
    └── MyMod.dll
```

## Next Steps

- Learn [debugging techniques](/en/guides/debugging/)
- Explore [common recipes](/en/recipes/common-patterns/)
- Check the [BepInEx API reference](/en/reference/bepinex-api/)