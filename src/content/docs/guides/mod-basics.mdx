---
title: Mod Development Basics
description: Core concepts and best practices for Resonite mod development
---

This guide covers essential concepts for developing Resonite mods with BepInEx.

## Understanding Resonite Architecture

### FrooxEngine
The core engine that powers Resonite:
- Handles world simulation
- Manages users and sessions
- Provides the component system
- Processes Protoflux

### Elements.Core
Low-level utilities and data structures:
- Math types (float3, floatQ, color)
- Collections and data structures
- Networking primitives

### Key Concepts

#### Worlds
- Each session has a World instance
- Contains the root slot hierarchy
- Manages users in the session
- Handles physics and updates

#### Slots
- Basic scene graph nodes
- Can have components attached
- Form parent-child hierarchies
- Have transforms (position, rotation, scale)

#### Components
- Add functionality to slots
- Examples: MeshRenderer, Collider, Light
- Can reference other components
- Update each frame or on-demand

#### Users
- Represent players in a world
- Have avatars and permissions
- Can be local or remote

## Harmony Patching

### What is Harmony?
Harmony is a library for patching .NET methods at runtime without modifying files.

### Patch Types

#### Prefix Patches
Run before the original method:
```csharp
[HarmonyPatch(typeof(World), "Initialize")]
[HarmonyPrefix]
static bool BeforeWorldInit(World __instance)
{
    // Return false to skip original method
    // Return true to continue
    return true;
}
```

#### Postfix Patches
Run after the original method:
```csharp
[HarmonyPatch(typeof(User), "Spawn")]
[HarmonyPostfix]
static void AfterUserSpawn(User __instance, Slot __result)
{
    // __result contains the return value
    // __instance is the object instance
}
```

#### Transpiler Patches
Modify IL code directly:
```csharp
[HarmonyTranspiler]
static IEnumerable<CodeInstruction> Transpiler(
    IEnumerable<CodeInstruction> instructions)
{
    // Advanced: Modify IL instructions
}
```

### Patch Parameters

Special parameter names Harmony recognizes:
- `__instance` - The instance (for non-static methods)
- `__result` - The return value (in postfix)
- `__state` - Pass data from prefix to postfix
- `___fieldName` - Access private fields (three underscores)

## Working with Components

### Finding Components
```csharp
// Find component on slot
var renderer = slot.GetComponent<MeshRenderer>();

// Find in children
var collider = slot.GetComponentInChildren<Collider>();

// Find all of type
var lights = slot.GetComponentsInChildren<Light>();
```

### Creating Components
```csharp
// Add component to slot
var text = slot.AttachComponent<TextRenderer>();
text.Text.Value = "Hello World";
text.Color.Value = color.Red;
```

### Component References
```csharp
// Reference another component
var driver = slot.AttachComponent<ValueCopy<float>>();
driver.Source.Target = sourceValue;
driver.Target.Target = targetValue;
```

## Working with Fields

### Field Types
- `Sync<T>` - Synchronized value
- `SyncRef<T>` - Reference to component/slot
- `SyncList<T>` - Dynamic list
- `AssetRef<T>` - Reference to asset

### Accessing Fields
```csharp
// Read value
float currentValue = myComponent.SomeFloat.Value;

// Write value
myComponent.SomeFloat.Value = 42.0f;

// Reference
myComponent.TargetSlot.Target = someSlot;
```

## Async Operations

### Using UniTask
```csharp
using Cysharp.Threading.Tasks;

public async UniTaskVoid MyAsyncMethod()
{
    await UniTask.Delay(1000); // Wait 1 second
    
    // Do something after delay
    await UniTask.SwitchToMainThread();
    // Now safe to modify Unity objects
}
```

### Coroutines
```csharp
StartCoroutine(MyCoroutine());

IEnumerator MyCoroutine()
{
    yield return new WaitForSeconds(1f);
    yield return new WaitForUpdate();
    yield return null; // Wait one frame
}
```

## Event Handling

### Common Events
```csharp
// World events
World.WorldManager.WorldAdded += OnWorldAdded;
World.WorldManager.WorldRemoved += OnWorldRemoved;

// User events  
world.UserJoined += OnUserJoined;
world.UserLeft += OnUserLeft;

// Component events
component.Changed += OnComponentChanged;
```

### Custom Events
```csharp
public static event Action<User> MyCustomEvent;

// Trigger event
MyCustomEvent?.Invoke(user);

// Subscribe
MyCustomEvent += HandleMyEvent;
```

## Performance Best Practices

### Caching
```csharp
// Bad: Finding component every frame
void Update()
{
    var renderer = GetComponent<MeshRenderer>();
    renderer.enabled = true;
}

// Good: Cache reference
MeshRenderer cachedRenderer;
void Start()
{
    cachedRenderer = GetComponent<MeshRenderer>();
}
void Update()
{
    cachedRenderer.enabled = true;
}
```

### Pooling
```csharp
// Reuse objects instead of creating new ones
Queue<Slot> slotPool = new Queue<Slot>();

Slot GetPooledSlot()
{
    if (slotPool.Count > 0)
        return slotPool.Dequeue();
    return world.RootSlot.AddSlot("Pooled");
}

void ReturnToPool(Slot slot)
{
    slot.ActiveSelf = false;
    slotPool.Enqueue(slot);
}
```

### Batching
```csharp
// Batch operations when possible
world.RunInUpdates(3, () =>
{
    // This runs after 3 updates
    // Good for batching changes
});
```

## Error Handling

### Try-Catch
```csharp
try
{
    // Risky operation
    var result = SomeMethod();
}
catch (Exception ex)
{
    MyMod.Logger.LogError($"Error: {ex.Message}");
    // Handle gracefully
}
```

### Null Checking
```csharp
// Always check for null
if (slot?.GetComponent<MeshRenderer>() is MeshRenderer renderer)
{
    // Safe to use renderer
}
```

### Validation
```csharp
if (!slot.IsValid || slot.IsDestroyed)
{
    Logger.LogWarning("Slot is invalid");
    return;
}
```

## Testing Your Mod

### Debug Logging
```csharp
// Different log levels
Logger.LogDebug("Debug info");
Logger.LogInfo("General info");
Logger.LogWarning("Warning");
Logger.LogError("Error occurred");
```

### Conditional Compilation
```csharp
#if DEBUG
    // Only in debug builds
    Logger.LogDebug($"Value: {someValue}");
#endif
```

### Test Worlds
Create specific test scenarios:
1. Empty world for isolation
2. Populated world for interaction
3. Multiplayer for networking

## Common Pitfalls

### Thread Safety
- FrooxEngine is not thread-safe
- Always use main thread for modifications
- Use `UniTask.SwitchToMainThread()`

### Reference Management
- Components can be destroyed
- Always check `IsValid` before use
- Use weak references when appropriate

### Memory Leaks
- Unsubscribe from events
- Dispose resources properly
- Clear references when done

## Next Steps

- Explore [BepInEx features](/en/guides/bepinex/)
- Learn [debugging techniques](/en/guides/debugging/)
- Check out [common recipes](/en/recipes/common-patterns/)