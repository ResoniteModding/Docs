---
title: Debugging & Development Environment
description: Set up your development environment and learn debugging techniques for Resonite mods
---

This guide covers setting up your development environment and debugging techniques for Resonite mod development.

## Development Environment Setup

### IDE Configuration

#### Visual Studio / Rider

1. Create a new Class Library project targeting `.NET 9.0`
2. Add references to required assemblies:
   ```xml
   <ItemGroup>
     <Reference Include="FrooxEngine">
       <HintPath>path\to\Resonite_Data\Managed\FrooxEngine.dll</HintPath>
       <Private>false</Private>
     </Reference>
     <Reference Include="Elements.Core">
       <HintPath>path\to\Resonite_Data\Managed\Elements.Core.dll</HintPath>
       <Private>false</Private>
     </Reference>
   </ItemGroup>
   ```

#### Visual Studio Code

1. Install the C# Dev Kit extension
2. Create a new folder for your mod project
3. Run `dotnet new classlib -n MyResoniteMod -f net9.0`
4. Create a `.vscode/settings.json` file:
   ```json
   {
   	"dotnet.defaultSolution": "MyResoniteMod.sln",
   	"files.associations": {
   		"*.cs": "csharp"
   	}
   }
   ```
5. Add required packages to your `.csproj`:

   ```xml
   <PropertyGroup>
     <TargetFramework>net9.0</TargetFramework>
     <LangVersion>latest</LangVersion>
   </PropertyGroup>

   <ItemGroup>
     <PackageReference Include="BepInEx.Core" Version="5.4.22" />
     <PackageReference Include="HarmonyX" Version="2.10.1" />
   </ItemGroup>

   <ItemGroup>
     <Reference Include="FrooxEngine">
       <HintPath>path\to\Resonite_Data\Managed\FrooxEngine.dll</HintPath>
       <Private>false</Private>
     </Reference>
     <Reference Include="Elements.Core">
       <HintPath>path\to\Resonite_Data\Managed\Elements.Core.dll</HintPath>
       <Private>false</Private>
     </Reference>
   </ItemGroup>
   ```

#### VSCode Debugging Setup

Create a `.vscode/launch.json` for debugging:

```json
{
	"version": "0.2.0",
	"configurations": [
		{
			"name": "Debug Resonite Mod",
			"type": "coreclr",
			"request": "attach",
			"processName": "Resonite.exe"
		}
	]
}
```

Create `.vscode/tasks.json` for build tasks:

```json
{
	"version": "2.0.0",
	"tasks": [
		{
			"label": "build",
			"command": "dotnet",
			"type": "process",
			"args": ["build", "${workspaceFolder}/MyResoniteMod.csproj"],
			"group": "build",
			"presentation": {
				"echo": true,
				"reveal": "silent",
				"focus": false,
				"panel": "shared"
			}
		},
		{
			"label": "copy to resonite",
			"command": "cp",
			"type": "shell",
			"args": [
				"${workspaceFolder}/bin/Debug/net9.0/MyResoniteMod.dll",
				"${env:RESONITE_PATH}/BepInEx/plugins/"
			],
			"dependsOn": "build",
			"group": "build"
		}
	]
}
```

#### Project Template

Create a basic mod structure:

```csharp
using BepInEx;
using BepInEx.Logging;
using HarmonyLib;

[BepInPlugin(GUID, NAME, VERSION)]
public class MyMod : BaseUnityPlugin
{
    public const string GUID = "com.example.mymod";
    public const string NAME = "My Resonite Mod";
    public const string VERSION = "1.0.0";

    internal static ManualLogSource Logger;
    private static Harmony harmony;

    private void Awake()
    {
        Logger = base.Logger;
        harmony = new Harmony(GUID);
        harmony.PatchAll();

        Logger.LogInfo($"{NAME} v{VERSION} loaded!");
    }

    private void OnDestroy()
    {
        harmony?.UnpatchSelf();
    }
}
```

### Build Configuration

#### Debug vs Release

Configure build settings in your project file:

```xml
<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
  <DebugSymbols>true</DebugSymbols>
  <DebugType>full</DebugType>
  <Optimize>false</Optimize>
  <DefineConstants>DEBUG;TRACE</DefineConstants>
</PropertyGroup>

<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
  <DebugType>pdbonly</DebugType>
  <Optimize>true</Optimize>
  <DefineConstants>TRACE</DefineConstants>
</PropertyGroup>
```

#### Auto-Deploy Script

Create a post-build script to automatically copy your mod:

```xml
<Target Name="PostBuild" AfterTargets="PostBuildEvent" Condition="'$(Configuration)'=='Debug'">
  <Exec Command="copy &quot;$(TargetPath)&quot; &quot;$(RESONITE_PATH)\BepInEx\plugins\&quot;" />
  <Exec Command="copy &quot;$(TargetDir)$(TargetName).pdb&quot; &quot;$(RESONITE_PATH)\BepInEx\plugins\&quot;" />
</Target>
```

Set `RESONITE_PATH` environment variable to your Resonite installation directory.

## Logging and Debugging

### BepInEx Logging

#### Log Levels

```csharp
Logger.LogDebug("Detailed debug information");
Logger.LogInfo("General information");
Logger.LogWarning("Warning message");
Logger.LogError("Error occurred");
Logger.LogFatal("Critical error");
```

#### Conditional Logging

```csharp
#if DEBUG
Logger.LogDebug($"Processing {items.Count} items");
#endif

// Or use conditional compilation
[System.Diagnostics.Conditional("DEBUG")]
private static void DebugLog(string message)
{
    Logger.LogDebug(message);
}
```

#### Custom Log Categories

```csharp
private static readonly ManualLogSource NetworkLogger =
    BepInEx.Logging.Logger.CreateLogSource("MyMod.Network");
private static readonly ManualLogSource UILogger =
    BepInEx.Logging.Logger.CreateLogSource("MyMod.UI");

NetworkLogger.LogInfo("Network event occurred");
UILogger.LogWarning("UI warning");
```

### Console Output

#### Enable Console Window

Add to your BepInEx config (`BepInEx/config/BepInEx.cfg`):

```ini
[Logging.Console]
Enabled = true
LogLevels = Fatal, Error, Warning, Info, Debug
```

#### Console Commands

Create debug commands for testing:

```csharp
[HarmonyPatch(typeof(FrooxEngine.ConsoleInterface), "ExecuteCommand")]
class ConsoleCommandPatch
{
    static bool Prefix(string command, ref string __result)
    {
        if (command.StartsWith("mymod."))
        {
            HandleMyModCommand(command.Substring(6));
            __result = "Command executed";
            return false;
        }
        return true;
    }

    static void HandleMyModCommand(string cmd)
    {
        switch (cmd)
        {
            case "test":
                Logger.LogInfo("Test command executed");
                break;
            case "info":
                Logger.LogInfo($"Mod version: {MyMod.VERSION}");
                break;
        }
    }
}
```

### In-Game Debugging

#### Debug UI

Create visual debug information:

```csharp
public class DebugUI : Component
{
    private TextRenderer debugText;

    protected override void OnAwake()
    {
        var textSlot = Slot.AddSlot("Debug Text");
        debugText = textSlot.AttachComponent<TextRenderer>();
        debugText.Text.Value = "Debug Info";
        debugText.Size.Value = 0.1f;
        debugText.Color.Value = color.Red;
    }

    protected override void OnCommonUpdate()
    {
        debugText.Text.Value = $"FPS: {Time.FPS:F1}\n" +
                              $"Users: {World.AllUsers.Count()}\n" +
                              $"Objects: {World.RootSlot.ChildrenCount}";
    }
}
```

#### Debug Gizmos

Visualize data in 3D space:

```csharp
// Draw lines for debugging
void DrawDebugLine(float3 start, float3 end, color col)
{
    var lineSlot = World.RootSlot.AddSlot("Debug Line");
    var line = lineSlot.AttachComponent<LineRenderer>();
    line.Points.Add().Position = start;
    line.Points.Add().Position = end;
    line.Material.Target = myLineMaterial;

    // Auto-destroy after 1 second
    lineSlot.CreateSpawner().Destroy(1f);
}
```

### Stack Traces and Exceptions

#### Exception Handling

```csharp
try
{
    // Risky operation
    RiskyMethod();
}
catch (Exception ex)
{
    Logger.LogError($"Exception in {nameof(RiskyMethod)}: {ex}");
    Logger.LogError($"Stack trace: {ex.StackTrace}");

    // Log additional context
    Logger.LogError($"World: {World?.Name ?? "null"}");
    Logger.LogError($"Users: {World?.AllUsers?.Count() ?? -1}");
}
```

#### Stack Trace Utilities

```csharp
using System.Diagnostics;

public static void LogStackTrace(string prefix = "")
{
    var stackTrace = new StackTrace(true);
    Logger.LogDebug($"{prefix}Stack trace:");
    for (int i = 1; i < stackTrace.FrameCount; i++)
    {
        var frame = stackTrace.GetFrame(i);
        var method = frame.GetMethod();
        Logger.LogDebug($"  {method.DeclaringType?.Name}.{method.Name}");
    }
}
```

## Performance Profiling

### Performance Monitoring

```csharp
using System.Diagnostics;

public class PerformanceMonitor
{
    private static readonly Stopwatch stopwatch = new Stopwatch();

    public static void StartTiming(string operation)
    {
        Logger.LogDebug($"Starting: {operation}");
        stopwatch.Restart();
    }

    public static void EndTiming(string operation)
    {
        stopwatch.Stop();
        var ms = stopwatch.ElapsedMilliseconds;
        var level = ms > 10 ? LogLevel.Warning : LogLevel.Debug;
        Logger.Log(level, $"Completed: {operation} ({ms}ms)");
    }
}

// Usage
PerformanceMonitor.StartTiming("Heavy Operation");
DoHeavyOperation();
PerformanceMonitor.EndTiming("Heavy Operation");
```

### Memory Usage

```csharp
public static void LogMemoryUsage(string context = "")
{
    var totalMemory = GC.GetTotalMemory(false);
    var workingSet = Environment.WorkingSet;

    Logger.LogInfo($"Memory {context}:");
    Logger.LogInfo($"  GC Memory: {totalMemory / 1024 / 1024}MB");
    Logger.LogInfo($"  Working Set: {workingSet / 1024 / 1024}MB");
}
```

## Testing Strategies

### Automated Testing

#### Unit Test Setup

Create test project targeting the same .NET version:

```csharp
[TestFixture]
public class MyModTests
{
    [SetUp]
    public void Setup()
    {
        // Initialize test environment
    }

    [Test]
    public void TestMyFunction()
    {
        // Arrange
        var input = "test";

        // Act
        var result = MyMod.ProcessInput(input);

        // Assert
        Assert.AreEqual("expected", result);
    }
}
```

#### Mock Objects

```csharp
// Create mock world for testing
public static World CreateTestWorld()
{
    var world = new World();
    world.Initialize("Test World");
    return world;
}
```

### Manual Testing

#### Test Scenarios

1. **Fresh World**: Test in empty worlds
2. **Populated World**: Test with existing content
3. **Multiplayer**: Test with multiple users
4. **Edge Cases**: Test with null/invalid data
5. **Performance**: Test with high loads

#### Test Checklist

```markdown
- [ ] Mod loads without errors
- [ ] All features work as expected
- [ ] No memory leaks after extended use
- [ ] Multiplayer synchronization works
- [ ] Graceful error handling
- [ ] Performance acceptable
- [ ] UI elements display correctly
- [ ] Settings save/load properly
```

## Launch Arguments for Development

### Recommended Developer Arguments

Add these to your Resonite launch options:

```bash
-SkipIntroTutorial -DoNotAutoLoadHome -NoUI -Screen-Width 1920 -Screen-Height 1080 -LogFile ResoniteLog.txt -ForceLegacyRenderer
```

#### Argument Explanations

- `-SkipIntroTutorial`: Skip intro for faster testing
- `-DoNotAutoLoadHome`: Don't load home world automatically
- `-NoUI`: Disable overlay UI (optional)
- `-Screen-Width/-Screen-Height`: Set resolution
- `-LogFile`: Specify log file location
- `-ForceLegacyRenderer`: Use legacy renderer if needed

### Development Batch File

Create `dev_launch.bat`:

```batch
@echo off
cd /d "C:\Path\To\Resonite"
start Resonite.exe -SkipIntroTutorial -DoNotAutoLoadHome -LogFile dev_log.txt
echo Resonite started in development mode
pause
```

## Remote Debugging

### Visual Studio Debugger

1. Enable "Enable native code debugging" in project properties
2. Attach to Resonite process:
   - Debug → Attach to Process
   - Select Resonite.exe
   - Make sure "Managed (.NET)" is selected

### Debug Symbols

Ensure PDB files are copied with your DLL:

```xml
<PropertyGroup>
  <DebugSymbols>true</DebugSymbols>
  <DebugType>portable</DebugType>
</PropertyGroup>
```

## Common Debug Scenarios

### Component Not Found

```csharp
var component = slot.GetComponent<MyComponent>();
if (component == null)
{
    Logger.LogWarning($"Component not found on slot: {slot.Name}");
    Logger.LogDebug($"Available components: {string.Join(", ",
        slot.Components.Select(c => c.GetType().Name))}");
}
```

### Field Access Issues

```csharp
try
{
    var value = component.MyField.Value;
}
catch (NullReferenceException)
{
    Logger.LogError($"Field access failed - Component: {component?.GetType().Name ?? "null"}");
    Logger.LogError($"Slot valid: {component?.Slot?.IsValid ?? false}");
}
```

### Harmony Patch Debugging

```csharp
[HarmonyPatch(typeof(TargetClass), "TargetMethod")]
class DebugPatch
{
    static void Prefix(object[] __args)
    {
        Logger.LogDebug($"Method called with args: [{string.Join(", ", __args)}]");
    }

    static void Postfix(object __result)
    {
        Logger.LogDebug($"Method returned: {__result}");
    }

    static Exception Finalizer(Exception __exception)
    {
        if (__exception != null)
            Logger.LogError($"Method threw exception: {__exception}");
        return __exception;
    }
}
```

## Log Analysis

### Log File Locations

- **BepInEx Log**: `BepInEx/LogOutput.log`
- **Resonite Log**: `Logs/` folder in Resonite directory
- **Unity Log**: Unity Console (accessible via mods)

### Log Parsing Tools

Create log analysis scripts:

```csharp
public static class LogAnalyzer
{
    public static void AnalyzeLogs(string logPath)
    {
        var lines = File.ReadAllLines(logPath);
        var errors = lines.Where(l => l.Contains("[Error]"));
        var warnings = lines.Where(l => l.Contains("[Warning]"));

        Logger.LogInfo($"Found {errors.Count()} errors, {warnings.Count()} warnings");

        foreach (var error in errors.Take(10))
            Logger.LogInfo($"Error: {error}");
    }
}
```

## Best Practices

### Debug Code Organization

```csharp
public static class DebugHelpers
{
    [Conditional("DEBUG")]
    public static void Assert(bool condition, string message)
    {
        if (!condition)
        {
            Logger.LogError($"Assertion failed: {message}");
            LogStackTrace();
        }
    }

    [Conditional("DEBUG")]
    public static void LogMethodEntry([CallerMemberName] string method = "")
    {
        Logger.LogDebug($"Entering: {method}");
    }
}
```

### Error Recovery

```csharp
public static T SafeExecute<T>(Func<T> func, T defaultValue = default(T))
{
    try
    {
        return func();
    }
    catch (Exception ex)
    {
        Logger.LogError($"Safe execution failed: {ex.Message}");
        return defaultValue;
    }
}
```

### Development Workflow

1. Write failing test
2. Implement feature
3. Run tests
4. Test in Resonite
5. Debug issues
6. Optimize performance
7. Document changes

This debugging guide should help you efficiently develop and troubleshoot your Resonite mods. Remember to always test thoroughly and handle errors gracefully!
